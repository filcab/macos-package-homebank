#!/usr/bin/env python3

from pathlib import Path

import argparse
import os
import shutil
import subprocess
import stat
import sys

parser = argparse.ArgumentParser(prog=sys.argv[0])
# path to homebank install dir (above bin/homebank)
parser.add_argument('formula')
parser.add_argument('--executable-name', default=None)
# destination .app
parser.add_argument('appdir')
args = parser.parse_args(sys.argv[1:])

brew_prefix = subprocess.check_output(['brew', '--prefix'],
                                      encoding='utf-8').strip()

formula_prefix = subprocess.check_output(
    ['brew', '--prefix', args.formula],
    encoding='utf-8'
    ).strip()

if os.path.islink(formula_prefix):
    formula_prefix = os.path.realpath(formula_prefix)

exe_name = args.executable_name
if not exe_name:
    exe_name = args.formula
original_binary = Path(formula_prefix)/f'bin/{exe_name}'

packaging_dir = Path(
    os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

appdir = Path(args.appdir)
contents = appdir/'Contents'
resources = contents/'Resources'
bindir = contents/'bin'
libdir = contents/'lib'
sharedir = contents/'share'
icon_file = sharedir/'icons/hicolor/256x256/apps/homebank.png'

print(f'brew prefix: {brew_prefix}')
print(f'formula: {args.formula}')
print(f'formula prefix: {formula_prefix}')


# We want to keep the name of the libraries, but resolve the directories
def realpath_for_dir(path):
    p = os.path
    return p.join(p.realpath(p.dirname(path)), p.basename(path))


def dependent_brew_libs(binary):
    lib_lines = subprocess.check_output(['otool', '-L', binary],
                                        encoding='utf-8').splitlines()[1:]
    return map(
        realpath_for_dir,
        [line.strip().split()[0] for line in lib_lines if brew_prefix in line])


def collect_libs(binary):
    queued = [binary]
    collected = set()
    while queued:
        binary = queued.pop()
        libs = set(dependent_brew_libs(binary))
        queued.extend(libs - collected)
        collected.update(libs)

    return sorted(list(collected))


os.makedirs(appdir)
# copy the full prefix first
shutil.copytree(formula_prefix, contents, symlinks=True)

binary = bindir/os.path.basename(original_binary)
libs = collect_libs(binary)
print('collected libs:')
for lib in libs:
    print(f'  {lib}')
# create the directory if it didn't exist
os.makedirs(libdir, exist_ok=True)
libdir_stat = libdir.stat()
libdir.chmod(libdir_stat.st_mode | stat.S_IWUSR)
for lib in libs:
    # don't copy if it's there already. Unsure why it's showing up
    if not Path(lib).is_relative_to(formula_prefix) \
            and not os.path.isfile(libdir/os.path.basename(lib)):
        print(f'copying {lib} to {libdir}')
        shutil.copy2(lib, libdir)

binary_stat = binary.stat()
binary.chmod(binary_stat.st_mode | stat.S_IWUSR)


def adjust_dylib_paths(binary, libs, echo=False):
    print(f'adjusting libs for {binary}')

    dep_libs = set(libs).intersection(dependent_brew_libs(binary))
    cmd = ['install_name_tool']
    for lib in dep_libs:
        cmd.extend(['-change', lib, f"@executable_path/../lib/{os.path.basename(lib)}"])
    cmd.append(binary)

    if echo:
        print(cmd)
    subprocess.run(cmd)


adjust_dylib_paths(binary, libs, echo=True)
for lib in os.listdir(libdir):
    # skip files/dirs like 'pkgconfig'
    if not lib.endswith('.dylib'):
        continue
    adjust_dylib_paths(libdir/lib, libs)

binary.chmod(binary_stat.st_mode)
libdir.chmod(libdir_stat.st_mode)

shutil.copy2(packaging_dir/'Info.plist', contents)
os.makedirs(resources)
shutil.copy2(icon_file, resources)
